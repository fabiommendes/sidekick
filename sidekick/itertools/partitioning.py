from .. import _toolz as toolz
from ..functions import fn
from ..typing import Seq, Func

not_given = object()
__all__ = ["fold_by", "reduce_by", "group_by"]


@fn.curry(2)
def group_by(key: Func, seq: Seq) -> dict:
    """
    Group collection by the results of a key function.

    Examples:
        >>> group_by((X % 2), range(5))
        {0: [0, 2, 4], 1: [1, 3]}

    See Also:
        count_by
        reduce_by
    """
    return toolz.groupby(key, seq)


@fn.curry(4)
def fold_by(key: Func, op, init, seq: Seq) -> dict:
    """
    Reduce each sequence generated by a group by.

    More efficient than performing separate operations since it does not
    store intermediate groups.

    Examples:
        >>> fold_by(X % 2, op.add, 0, [1, 2, 3, 4, 5])
        {1: 9, 0: 6}

    See Also:
        fold
        group_by
        reduce_by
    """
    return toolz.reduceby(key, op, seq, init)


@fn.curry(3)
def reduce_by(key: Func, op, seq: Seq) -> dict:
    """
    Similar to reduce_by, but only works on non-empty sequences.

    Initial value is taken to be the first element in sequence.

    Examples:
        >>> reduce_by(X % 2, op.add, [1, 2, 3, 4, 5])
        {1: 9, 0: 6}
    """
    return toolz.reduceby(key, op, seq)
